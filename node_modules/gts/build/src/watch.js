"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const execa = require("execa");
const path = require("path");
const ts = require("typescript");
const formatHost = {
    getCanonicalFileName: path => path,
    getCurrentDirectory: ts.sys.getCurrentDirectory,
    getNewLine: () => ts.sys.newLine
};
// Use the TypeScript compiler API to implement watch.
// See: https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API
function watch(options) {
    const tsconfigPath = path.join(options.targetRootDir, 'tsconfig.json');
    // Incremental builder that emits.
    const createProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram;
    const host = ts.createWatchCompilerHost(tsconfigPath, {}, ts.sys, createProgram, reportDiagnostic, reportWatchStatusChanged);
    const origAfterProgramCreate = host.afterProgramCreate;
    host.afterProgramCreate = program => {
        const ret = origAfterProgramCreate(program);
        // There is probably a better way to do this ü§∑‚Äç‚ôÇÔ∏è.
        const errors = program.getSemanticDiagnostics().length +
            program.getSyntacticDiagnostics().length;
        const command = (errors === 0 && options.thenCommand) ||
            (errors !== 0 && options.elseCommand) || null;
        if (command) {
            const child = execa.shell(command);
            child.stdout.pipe(process.stdout);
            child.stderr.pipe(process.stderr);
        }
        return ret;
    };
    ts.createWatchProgram(host);
    return true;
}
exports.watch = watch;
function reportDiagnostic(diagnostic) {
    console.error(`Error ${diagnostic.code}:`, ts.flattenDiagnosticMessageText(diagnostic.messageText, formatHost.getNewLine()));
}
function reportWatchStatusChanged(diagnostic) {
    console.info(ts.formatDiagnostic(diagnostic, formatHost));
}
//# sourceMappingURL=watch.js.map